wc -> 
wc -c Count chars
wc -l Count lines
wc -w Count words
wc -L gives the line whose char count is maximum in the file
wc gives all kinds of count


head ->
head -c "n" stdout n chars from the first of its stdin
head -n "n" Stdout n lines from its stdin


tail ->
tail -b "n" stdout n chars form last of its stdin
tail -n "n" stdout n lines from from last of its stdin
tail -f Waits till last when input comes. It acts like deno --watch

sort ->
sort -c Checks if the given stdin or file is in sorted manner or not
sort -o "somefile.txt" print the output to the output file "somefile.txt"
sort -u Stdout only the unique things after sorting
sort -r Sort in reverse order
sort -R Sort in random order
sort -t It is used to separate the string based on a certain string. Default is \0


sleep -> "time in second" -> Sleeps till the time


yes -> "word" | Prints "word" for infinite time default is "y"


seq ->
seq -f "%.2f" Handles decimals for floating point numbers default is "%g" can take "%f" as well
seq -f "%03g" Handles 0s for general numbers default is "0" is to pad with "3" is for no of times "g" means general number
seq -s "," Uses the given string to separate numbers of a sequence
seq -t "" Uses the given string to terminate the sequence of numbers
seq -w Adds 0s in front to equalize the width of all numbers


uniq ->
uniq -c Gives no. of times each entry has occured with that entry separated by space
uniq -d If some string repeats for more than once sequentially then it'll show only one string
uniq -D same as -d but it shows the values as it is same as the number of times it occured
uniq -f It's kinda same as -d only difference is it takes an argument to skip that much string from front before it starts comparing 
uniq -i It's kinda similar to -d only difference is it checks regardless of cases
uniq -u Gives the values whose frequency is 1 in the file


less -> Less allows us to read by scrolling. First it shows a certain amount of string from that file then we have to scroll and see the other contents. We have to press q to quit from less


nl ->
nl -b To number lines based on certain input
      a -> To give numbering on each line starts from 1
      t -> To give numbering only in the non-empty lines
      n -> To give no line numbering

nl -i It specifies the increment value for numbering each lines
nl -l Takes number of empty lines for numbering with a line number
nl -v Takes the starting number to start the counting for numbering lines


kill -> It is used to kill a process in various ways
1       HUP (hang up)
2       INT (interrupt)
3       QUIT (quit)
6       ABRT (abort)
9       KILL (non-catchable, non-ignorable kill)
14      ALRM (alarm clock)
15      TERM (software termination signal)


cut -> 
cut -d "," It is used to cut or split based on a specific string. here it's ","
cut -b 1-5 It is used to cut bytes from a string. Here it's 1-5
cut -c1 It is used to specify character positions in a string. Here it is first character
cut -w It uses whitespaces to cut or split between strings
cut [-d or -w] -f 1-n to see the output


grep -> It works line by line. Basically filter lines based on string
grep '^': start of the line followed by some string given after it
```
grep "^P" 
output:
Pradip
Pradip
hello
please 
```     

grep '$': any strings followed by end of line
```
grep "a$"
output:
India
India
hello
```

".": It matches with any one character
```
grep "^.$"
output: -> checks only one character
a
a
ab
```

"*": 0 or more occurence of the previous character of "*"

"+": 1 or more occurence of the previous character of "+"

"-": - is a cool thing. Which works as operator when we put it between two chars. If not then works as normal character

[]: It is used to specify bunch of characters together to match To

"?": Maximum 1 occurence of the previous character of "?" (0 or 1)
"\": It is used to specify a special character as a normal character in a string

```
grep "a\?"
Exp: For this it will check every byte in the string about the occurence of a
output:
a
a
aaaa
aaaa
aba
aba
bbb
bbb
```

grep -o Gives only matched string as output
grep -w Checks if the given string is an independent word of a sentence. It can be a single word as well.
grep -F Treats the whole pattern as a normal string.
```
grep -F "a.\+a"
output:
a 
aa
a.\+a
a.\+a
```
```
grep "^[1-9][1-9][02468]$"
```

[0-9] : Can be written as \d
\s : It means all whitespace characters
\S : It means all non whitespaces characters

tr: Translates a character with another character
tr -C 'string1' 'string2' Whatever contains string1 other than that anything will be converted into string2
```
tr -C 'ab' 'p'
output: 
abcd
abppp
```
tr -c 'string1' 'string2' same as -C but it can only work on a single character
```
tr -c 'a' 'p'
output:
pradipta
ppappppap
abcd
apppp
```
tr -d 'string' Deletes the given character from input
```
tr -d 'a'
output:
Pradpita         
Prdpit
aaabcda   
bcd
```
tr -s 'string' It squeezes the given character to a single one.
```
tr -s 'a'
output:
pradipta
pradipta
aaaaaaaa
a
```

grep Capture:
      \(\) -> To declare a Capture

```
Description: starts and ends with the same string separated by " : " `space colon space`
\1$: It is used to specify the capture number. Here it is first capture

grep "^\(\w*\) : \1$"
output:
hello
hello hello
hello : hello
hello : hello
```

```
Description: start of the line followed by 0 or more alpha-numeric characters followed by " : " followed by 0 or more numeric characters.
\1 \2$: It says the first capture followed by space followed by second capture followed by end of line

grep "^\(\w*\) : \(\d*\) \1 \2$"
hello : 123 hello 123
hello : 123 hello 123
hello 123 hello 123
```

```
Description: Captures two things then both have to occur exactly twice in a row
\{\}: It is used to specify the number of times one capture should appear

grep "^\(\w*\) : \(\d*\) \1\{2\} \2\{2\}$"
hello : 123 hellohello 123123
hello : 123 hellohello 123123
```